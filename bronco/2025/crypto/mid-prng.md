# Mid PRNG - Writeup

This challenge let us connect to a remote whith this backend:

```py
import bad_prng
import random

flag = ""

output = []
random = bad_prng.generate_seed()
for c in flag:
    random = bad_prng.rand_word()
    output.append(random ^ ord(c))

print(bytes(output).hex())
```

The difficulty reside in the fact that we do not have access to the `bad_prng` source code.
However, we know that the flag starts with: `bronco{` and that `bad_prng.rand_word()` return a byte beetween 0 and 256 because of the fact we do not have verifications in `bytes(output).hex()`

Knowing the beginning of the flag, we can retrieve the first value of the prng with this script:

```py
# dumped from the remote.
ct = bytes.fromhex("59c37c57c86e7839700ec2adf8fe8d998faeb40b5875b734")
ciphertext = list(ct)
prefix = "bronco{".encode('utf-8')

X = []
for i in range(len(prefix)):
    random_value = ciphertext[i] ^ prefix[i]
    X.append(random_value)

for i, val in enumerate(X):
    print(f"X_{i+1}: {val}")
```
```
❯ python get_first_Xn.py
X_1: 59
X_2: 177
X_3: 19
X_4: 57
X_5: 171
X_6: 1
X_7: 3
```

To solve this problem, we need to identify the numeric sequence that represents the PRNG.

We can express this sequence as:

$u_0 = \text{seed}$

$u_n = f(u_{n-1}) \pmod{256}$

where $u_0$ is the initial seed, and $u_n$ represents the $n^{th}$ random byte generated by the PRNG.  The function $f$ defines how each term in the sequence is derived from the previous one.

After some testing and analysis of the recovered values, we find that the function $f$ is a simple multiplication:

$f(x) = 3x$

```py
U = [59, 177, 19, 57, 171, 1, 3]
f = lambda u_n: (3 * u_n) % 256

for i in range(len(U) - 1):
    assert f(U[i]) == U[i + 1]

print(f"Done.")
```
```
❯ python test.py
Done.
```

From this we can easily guess the next bytes of the flag.

## solve.py

```py
ct = bytes.fromhex("59c37c57c86e7839700ec2adf8fe8d998faeb40b5875b734")
ciphertext = list(ct)
flag = ""

f = lambda u_n: (3 * u_n) % 256
u_0 = 59

for i in range(len(ciphertext)):
    flag += chr(ciphertext[i] ^ u_0)
    u_0 = f(u_0)

print(flag)
```
